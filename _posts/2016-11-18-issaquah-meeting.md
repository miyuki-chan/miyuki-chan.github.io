---
layout: post
comments: true
title: 'Issaquah meeting trip report'
tags:
  - 'C++'
---

This November I visited the C++ Standards Committee meeting in Issaquah and
decided to write a blog post about it.

<img src="/assets/issaquah-cxx-meeting.jpg" style="width: 100%;">

The complete list of submitted proposals is presented in the
[pre-Issaquah mailing](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/#mailing2016-10).
As you can see, this list contains over 100 papers.

I spent most of the week with the Evolution Working Group (EWG) and a couple of
days with the Library Evolution Working Group (LEWG). More information about the
structure of the committee is available
[here](https://isocpp.org/std/the-committee).

I'll start with the work of EWG, i.e. proposals for the core language.

We discussed the bitfield initializer proposal
[P0187R1](http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0187r1.pdf). The
committee is in favor of the most natural syntax for such initializers:

{% highlight C++ %}
int x : 5 = 42;
{% endhighlight %}

I'm glad that EWG decided to get rid of the quirks in the original proposal.
However the new syntax does have its problems:

```
int y : true ? 1 : a = 42Í¾
```

`= 42` is an initializer, not a part of ternary operator. The grammar will need
some disambiguation rules. Chandler found an interesting
[bug](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=78280) in GCC related to
bitfield width (or rather, constant-expressions in general) parsing.

The committee continues to explore the design space of compiler-generated
comparison operators. Walter E Brown presented his proposal
[P0436R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0436r0.pdf)
which would allow the compiler to convert, say, `x != y` into `!(x == y)` and
`x > y` into `y < x` (if the latter is provided by user, but the former isn't). I
really like this proposal. In future it can be extended to generate, say
`operator->` in terms of `operator*`, but even in its current variant it will
save us from writing lots of boilerplate code. Unfortunately, the proposal as-is
did not satisfy the committee (hopefully, either Walter or someone else will
eventually fix it). The two other proposals that were presented are
[P0481R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0481r0.pdf)
and
[P0432R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0432r0.html).
The major concern of the committee is whether or not any comparisons should be
generated by default. The opt-in comparisons get more consensus than the default
ones. We also discussed the idea of introducing the
[three-way comparison](https://en.wikipedia.org/wiki/Three-way_comparison) (a.k.a
spaceship) operator into C++. Microsoft and Google folks seem to be in favor of
it, but no formal proposal exists yet. Lawrence Crowl proposes to add three-way
comparisons as a library function in
[P0474R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0474r0.html),
he told me that he is also in favor of the operator, but decided to stick with
the library approach, because it is easier to push through the committee.

I presented my proposal
[P0412R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0412r0.html)
on benchmarking primitives (slides are available
[here](/cxx/slides/benchmarking.html)). It adds some facilities to avoid
interference with certain compiler optimizations when performing
microbenchmarking. The committee was in favor of the proposal and encouraged me
to continue work in that direction. Another proposal in performance area is
[P0479R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0479r0.html),
which discusses `likely` and `unlikely` attributes (it tries to standardize
an analog of a well-known GCC intrinsic
[__builtin_expect](https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html)). It
was suggested to put these attributes on arbitrary statements rather than
conditions of `if` statements.

Louis Dionne, the author of [Boost.Hana](http://www.boost.org/doc/libs/1_61_0/libs/hana/doc/html/index.html)
metaprogramming library presented several proposals.
[P0428R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0428r0.pdf)
will make generic lambdas even more generic. For example, it will allow us
to write:

{% highlight C++ %}
auto f = []<typename T>(std::vector<T> vector) {
// ...
};
{% endhighlight %}

This syntax was originally present in GCC's implementation of generic lambdas
(before they were standardized).

[P0315R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0315r0.pdf)
will allow to use lambdas in unevaluated contexts (e.g., in `decltype`). The
committee was in favor both of these proposals.

Paper
[P0424R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0424r0.pdf)
proposes a feature which would allow us to use string literals as non-type
template parameters. This proposal was rejected because of compilation
performance concerns. Louis provides
[some details](https://groups.google.com/a/isocpp.org/forum/?utm_medium=email&utm_source=footer#!msg/std-proposals/pe7hz70Q7h0/PPESBiNkAQAJ)
on std-discussions forum.

A 40-page proposal
[P0465R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0465r0.pdf)
presents some ideas on how C++ code can be annotated to facilitate formal
verification of program correctness. It largely overlaps with the contracts
proposal
[P0380R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf),
but has some new ideas (e.g., how to specify function postconditions in
presence of unhandled exceptions). One major drawback of this proposal is that
it is very far from being complete and lacks details necessary for
implementation. It would be nice if the author of P0465 directed her efforts
at enhancing the contracts proposal.

Gor Nishanov's coroutines (gorroutines :) ) proposal
[P0057R6](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0057r6.pdf)
was presented to CWG. As you might notice, it's already the sixth revision.
There is also some implementation experience (in Clang and MSVC), so it looks
like we will soon get the Coroutines Technical Specfication. Nevertheless, some
folks are not satisfied with the current approach.
[P0444R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0444r0.pdf)
expresses their concerns. The author of this paper and Torvald Riegel
think that the standard should also support stackful coroutines (P0057
coroutines are stackless), and that it would be nice to somehow unify syntax
of both kinds of coroutines to facilitate code reuse.

Static reflection proposals (wording:
[P0194R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0194r2.html)
and rationale:
[P0385R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0385r1.pdf))
are finally ready for review by EWG and LEWG at the next meeting. It's a huge
milestone for this proposal.

Library evolution working group spent most of the week discussing National Body
comments (that is, mostly fixing bugs in upcoming C++17). 11 of these
comments were dedicated to a new feature of C++17 called "template argument
deduction guides" (proposal
[P0091R3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r3.html)).
The idea expressed in this proposal is really nice: it will allow to deduce class
templates arguments from constructor invocation:

{% highlight C++ %}
std::tuple t(1, 'a');
{% endhighlight %}

In this example the type of `t` will be deduced to `std::tuple<int, char>`.
Ideally, this will allow to get rid of `std::make_tuple` and other factory
functions in the future. Proposal
[P0433R0](http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0433r0.html)
tries to make use of this new core language feature in the standard library.
Indeed, using a new feature in such a big and complex library is a good test for
the feature. Walter Brown even advocated for applying such policy for every new
language feature.

Some smallish tweaks for C++17 were also accepted. Russian National Body
representative Antony Polukhin presented his proposal [P0426R0](https://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0426r0.html)
to make `char_traits` fully constexpr. The effect of this proposal is that
`string_view` will also become constexpr. Another accepted paper related to
`string_view` is [P0403R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0403r0.html),
which adds literal suffixes for `string_view`. One will now be able to write:

{% highlight C++ %}
// equivalent to string_view("Hello")
auto s = "Hello"sv;
{% endhighlight %}

Unfortunately, very little time was left for C++Next (i.e. likely C++20)
proposals. Howard Hinnant presented
[P0463R0](http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0463r0.html)
which adds an enum class `endian`. As the name suggests, it has enumerators for
endianness. Concretely, it defines `endian::little`, `endian::big` and
`endian::native` (which is equal to either `big` or `little` on "sane"
platforms). We will now have a portable way to detect endianness at compile
time.

[P0429R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0429r0.pdf)
introduces a new container called `flat_map`. It's an associative container
based on sorted vector, which has much better traversal performance compared
to `map` and `unordered_map` at the cost of linear-time insertions. It is
a part of the [Boost.Container](http://www.boost.org/doc/libs/1_62_0/doc/html/container/non_standard_containers.html#container.non_standard_containers.flat_xxx)
library.

During the Saturday session I presented [P0457R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0457r0.html)
(slides are available [here](/cxx/slides/starts_with.html))
&mdash; a proposal to add `starts_with` and `ends_with` methods to `string` and
`string_view` that check whether a given string starts with (or ends with
respectively) another given string or character. LEWG was in favor of the
proposal and hopefully I'll present it to LWG during the meeting in Toronto.

Another nice addition to C++Next is [P0477R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0477r0.pdf)
which adds a template class `monostate_function` which will allow us to
convert any callable object (for example, a function pointer) into a
function object suitable for use as a comparator or hash function. This
will reduce the amount of boilerplate code in the following example:

{% highlight C++ %}
struct custom_compare_t {
    bool operator()(int lhs, int rhs) const {
        return custom_compare(lhs, rhs);
    }
};
std::set<int, custom_compare_t> ints;
{% endhighlight %}

which can now be rewritten as

{% highlight C++ %}
std::set<int, std::monostate_function<custom_compare>> ints;
{% endhighlight %}

To summarize, this meeting was largely devoted to fixes for C++17. The next
meetings in Kona and Toronto will be more centered around C++Next.
