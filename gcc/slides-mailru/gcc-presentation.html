<!doctype html>
<!-- #region HTML header -->
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>Внутреннее устройство и оптимизации компилятора GCC</title>

  <!-- reveal.js - presentation framework -->
  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/font-awesome.min.css">
  <link rel="stylesheet" href="css/theme/white.css">
  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/github-gist.css">

  <style type="text/css">
    .reveal .slides {
      font-size: 0.8em;
    }
    .reveal .slides { text-align: left; }
    .reveal .slides img {
      margin: 0;
      border: none;
      box-shadow: none;
    }
    .reveal pre {
      margin: 0;
      font-size: 26px;
      width: 100%;
    }
    .reveal pre code {
      line-height: normal;
      font-size: 24px;
      max-height: 600px;
    }
    .reveal tt {
      font-family: monospace;
      font-weight: bold;
    }

    .reveal blockquote {
      width: 90%;
    }

    /* List with tick marks */
    ul.fa-ul {
      list-style-type: none;
    }
    ul.fa-ul li i.fa-check-square {
      color: green;
    }
    ul.fa-ul li i.fa-bug  {
      color: red;
    }

    .reveal .slides span.todo:before { content: "TODO "; }
    .reveal .slides span.todo {
      font-size: 36px;
      font-weight: bold;
      color: red;
    }

    .reveal,
    .reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5, .reveal h6 {
      text-transform: none;
      font-family: "Arial", Helvetica, sans-serif;
    }

    /* For title slide */
    .reveal .slides h1,
    .reveal .slides h2 {
      text-align: center;
      font-size: 72px;
    }

    .reveal .slides h3 {
      font-size: 36px;
    }

    .reveal .slides div.center-wrapper { text-align: center; }

    .reveal .slides div.half {
      float: left;
      width: 48%;
      padding-right: 10px;
    }

    /* Title and last slide - short link to this presentation */
    .reveal .slides div.link-bitly {
      padding-top: 36px;
      font-size: 48px;
      font-family: monospace;
      text-align: right;
    }

    .reveal .slides .cmdline {
      padding: 0.1em;
      border: 1px solid #ccc;
      border-radius: 5px;
      font-family: monospace;
      font-weight: bold;
      background-color: #f8f8f8;
    }
  </style>
  <link rel="stylesheet" href="css/fragments.css">
  <link rel="stylesheet" href="css/tree-list.css">
</head>
<body>
<div class="reveal"><div class="slides">
<!-- #endregion -->

<!-- #region Введение -->
  <section>
    <h1>Внутреннее устройство и оптимизации компилятора GCC</h1>
    <div class="center-wrapper"><b>Михаил Мальцев</b></div>
    <div class="link-bitly"><a href="https://bit.ly/gcc_">
      <i class="fa fa-external-link"></i> bit.ly/gcc_</a>
    </div>
  </section>

  <section>
    <img src="images/gnu-toolchain.svg">
    <aside class="notes">
      По поводу того, что именно называть toolchain-ом единого мнения нет.
      GCC, gdb, glibc, binutils - 4 отдельных проекта, но всё же довольно тесно связаны
      друг с другом (переиспользование кода, много общих разработчиков, API для
      взаимодействия, и т.д.).<br>
      Тем не менее, компоненты взаимозаменяемы. Например, на AIX
      используется собственный компоновщик, на встраиваемых системах своя стандартная библиотека C
      (musl, newlib).
    </aside>
  </section>

  <section>
    <h3>Взаимодействие компонентов toolchain-а</h3>
    <div class="center-wrapper">
      <img src="images/build-flow.svg">
    </div>
    <aside class="notes">
      Сплошные линии - преобразование данных<br>
      Пунктирные линии - косвенное влияние на преобразование (проверка ошибок)<br>
      Обратить внимание аудитории на "cc1"
    </aside>
  </section>

  <section>
    <h3>Компоненты проекта GCC</h3>
    <img src="images/gcc-logo.png" style="float: right; width: 20%; padding-left:0;">
    <div style="float:left; width: 80%">
      <ul>
        <li>Собственно компиляторы нескольких языков</li>
        <li class="fragment semi-fade-out" data-fragment-index="1">
          Стандартные библиотеки этих языков</li>
        <li class="fragment semi-fade-out" data-fragment-index="1">
          Вспомогательные низкоуровневые библиотеки</li>
        <li class="fragment semi-fade-out" data-fragment-index="1">
          Библиотеки для взаимодействия с компоновщиком и отладчиком</li>
        <li class="fragment semi-fade-out" data-fragment-index="1">
          Инструменты для анализа покрытия кода</li>
        <li>Программа-драйвер
          <span class="fragment" data-fragment-index="2" style="color:red;">
            <i class="fa fa-arrow-left"></i>
          </span>
        </li>
      </ul>
    </div>
  </section>

  <!-- Неразрывные дефисы: https://stackoverflow.com/a/14424029/4142343 -->
  <section>
    <h3>Драйвер</h3>
    <p>
      <span class="cmdline"><i class="fa fa-terminal"></i> g++ hello.cc get_name.cc &#8209;o hello</span>
    </p>
    <ul class="tree" style="font-size:24px; line-height:36px;">
      <li><div><tt><span class="fragment highlight-red" data-fragment-index="1">cc1plus</span>
        &hellip; &#8209;D_GNU_SOURCE hello.cc &hellip; &#8209;o /tmp/ccEB1OJZ.s</tt></div></li>
      <li><div><tt>as &#8209;&#8209;64 &#8209;o /tmp/ccl07rju.o /tmp/ccEB1OJZ.s</tt></div></li>
      <li><div><tt><span class="fragment highlight-red" data-fragment-index="1">cc1plus</span>
        &hellip; &#8209;D_GNU_SOURCE get_name.cc &hellip; &#8209;o /tmp/ccV8R7Kz.s</tt></div></li>
      <li><div><tt>as &#8209;&#8209;64 &#8209;o /tmp/cclcWKS5.o /tmp/ccV8R7Kz.s</tt></div></li>
      <li><div><tt>collect2 &hellip; &#8209;o hello /tmp/ccaYahDP.o /tmp/cclcWKS5.o &#8209;lstdc++ &hellip;</tt></div>
        <ul class="tree">
          <li><div><tt>ld &hellip; &#8209;o hello /tmp/ccaYahDP.o /tmp/cclcWKS5.o &#8209;lstdc++ &hellip;</tt></div></li>
        </ul>
      </li>
    </ul>
  </section>

  <section>
    <h3>На заметку: полезные возможности драйвера</h3>
    <ul>
      <li>Выполнить компиляцию, вывести список исполненных команд:<br>
        <div class="cmdline"><i class="fa fa-terminal"></i> gcc -v main.c other.c &hellip;</div>
      </li>
      <li>Вывести список команд, не исполняя их (dry run):<br>
        <div class="cmdline"><i class="fa fa-terminal"></i> gcc -### main.c other.c &hellip;</div>
      </li>
    </ul>
  </section>
<!-- #endregion -->

<!-- #region Компилятор GCC и его архитектура -->
  <section>
    <h2>Компилятор GCC и его архитектура</h2>
  </section>

  <section>
    <h3>Задачи компилятора</h3>
    <ul>
      <li>Трансляция кода из ЯВУ в язык ассемблера</li>
      <li class="fragment" data-fragment-index="1">Валидация программы, вывод сообщений об ошибках</li>
      <li class="fragment" data-fragment-index="1">Статический анализ, вывод предупреждений</li>
      <li class="fragment" data-fragment-index="2">Оптимизация</li>
      <li class="fragment" data-fragment-index="3">Инструментальная обработка
        программы (профилирование, динамические проверки)</li>
      <li class="fragment" data-fragment-index="3">Генерация отладочной информации</li>
      <li class="fragment" data-fragment-index="3">Взаимодействие со сторонними программами
        (система сборки, отладчик, IDE)</li>
    </ul>
  </section>

  <section>
    <h3>Перенастраиваемость</h3>
    <div class="center-wrapper">
      <img src="images/retargetability.svg" height="550px;">
    </div>
  </section>

  <section>
    <h3>Структура сферического компилятора в вакууме</h3>
    <div class="center-wrapper">
      <img src="images/compiler-internals.svg" height="500px;">
    </div>
  </section>
<!-- #endregion -->

<!-- #region Front end, промежуточное представление -->
  <section>
    <h2>Front end, промежуточное представление</h2>
  </section>

  <section>
    <h3>Задачи фронтэнда</h3>
    <ul>
      <li>Разбор программы, семантический анализ</li>
      <li>Валидация и выдача сообщений об ошибках</li>
      <li>Выдача предупреждений</li>
      <li>
        Трансляция в промежуточное представление, в т.ч.:
        <ul>
          <li>Генерация служебного кода</li>
          <li>Упрощение конструкций языка</li>
          <li>Сохранение отладочной информации</li>
        </ul>
      </li>
  </section>

  <section>
    <h3>Разбор, семантический анализ</h3>
    <div class="half">
      <pre><code class="cpp" data-trim data-noescape>typedef struct {
    uint8_t h;
    uint8_t m;
} hh_mm;

bool
first_is_gt(hh_mm a, hh_mm b) {
<mark>    if (a.h > b.h)
        return true;</mark>
    if (a.h == b.h)
        return a.m > b.m;
    return false;
}
      </code></pre>
    </div>
    <div class="half">
      <ul class="tree" style="font-size:24px; line-height:32px; font-family:monospace;">
        <li>stmt
          <ul class="tree">
            <li><div>cond_expr</div>
              <ul class="tree">
                <li><div>gt_expr</div>
                  <ul class="tree">
                    <li><div>component_ref</div>
                      <ul class="tree">
                        <li><div>parm_decl <b>a</b></div></li>
                        <li><div>field_decl <b>h</b></div></li>
                      </ul>
                    </li>
                    <li><div>component_ref</div>
                      <ul class="tree">
                        <li><div>parm_decl <b>b</b></div></li>
                        <li><div>field_decl <b>h</b></div></li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li><div>return_expr</div>
                  <ul class="tree">
                    <li><div>modify_expr</div>
                      <ul class="tree">
                        <li><div>result_decl D.2143</div></li>
                        <li><div>integer_cst 1</div></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </div>
  </section>

  <section>
    <h3>Подробнее про разбор и семантический анализ</h3>
    <img src="images/dragon_book.jpg" style="float: right; width: 20%;">
    <div style="float: left; width: 80%;">
      <p>Классика: &laquo;Книга Дракона&raquo;</p>
      <ul>
        <li><a href="https://www.amazon.com/gp/product/0321486811">
          <i class="fa fa-book"></i>
          Compilers: Principles, Techniques, and Tools (2nd Edition)</a></li>
        <li><a href="http://www.williamspublishing.com/Books/978-5-8459-1349-4.html">
          <i class="fa fa-book"></i>
          Компиляторы: принципы, технологии и инструментарий, 2 издание</a></li>
      </ul>
    </div>
  </section>

  <section>
    <h3>Трансляция</h3>
    <p>Если в программе не выявлено ошибок, начинается процесс её перевода в промежуточное
      представление, которое:<br>
      <ul>
        <li>(почти) не зависит от исходного языка и целевой архитектуры</li>
        <li>удобно для работы оптимизатора</li>
        <li>позволяет выразить типичные инструкции, доступные современным процессорам</li>
      </ul>
    </p>

  </section>

  <section>
    <h3>Упрощение конструкций языка</h3>
    <p>На примере языка C++:</p>
    <ul>
      <li>Классы</li>
      <li>Шаблоны</li>
      <li>Лямбда-выражения и замыкания</li>
      <li>Ranged-based циклы</li>
    </ul>
    <aside class="notes">
      Упомянуть, что это называется синтаксическим сахаром
    </aside>
  </section>

  <section>
    <h3>Пример: методы классов</h3>
      <pre style="margin-bottom: 10px;"><code class="cpp" data-trim data-noescape>class my_class {
public:
  my_class(int a, int b) : m_a(a), m_b(b) { }
  int get_sum() { return m_a + m_b; }
private:
  int m_a, m_b;
};</code></pre>

      <pre><code class="pure-c" data-trim data-noescape>struct my_class {
  int m_a, m_b;
};

void <mark>_ZN8my_classC2Eii</mark>(struct my_class *this, int a, int b) {
  this->m_a = a;
  this->m_b = b;
}

int <mark>_ZN8my_class7get_sumEv</mark>(struct my_class *this) {
  return this->m_a + this->m_b;
} </code></pre>
  </section>

  <section>
    <h3>Пример: составные выражения</h3>
    <pre style="margin-bottom: 10px;"><code class="c" data-trim data-noescape>void copy(char *dest, const char *src) {
  while (*dest++ = *src++)
    ;
}   </code></pre>
    <pre><code class="c" data-trim data-noescape>void copy(char *dest, const char *src) {
  char *dest_tmp, *src_tmp;
  do {
    dest_tmp = dest;
    dest = dest_tmp + 1;
    src_tmp = src;
    src = src_tmp + 1;
    char val = *src;
    *dest_tmp = val;
  } while (val != 0);
}</code></pre>
  <aside class="notes">
    Сказать про трёхадресный код. Неопределённое поведение вида "i++ + ++i"
  </aside>
  </section>

  <section>
    <div class="center-wrapper">
      <img src="images/meme_go_deeper.jpg" width="80%">
    </div>
    <aside class="notes">
      Мы избавились далеко не ото всех абстракций
    </aside>
  </section>

  <section>
    <h3>Области видимости</h3>
    <div class="half">
      <pre><code class="cpp" data-trim data-noescape>void foo(int a, int b) {
  if (a > b) {
    int x = a, y = b;
    bar(x, y);
  } else {
    int <span style="color:red;">a</span> = 1, <span style="color:blue;">y</span> = 2;
    baz(<span style="color:red;">a</span>, <span style="color:blue;">y</span>);
  }
}</code></pre>
    </div>
    <div class="half">
      <pre><code class="cpp" data-trim data-noescape>void foo(int a, int b) {
  int x, y_1, y_2, a_2;
  if (a > b) {
    x = a; y_1 = b;
    bar(x, y_1);
  } else {
    a_2 = 1; y_2 = 2;
    baz(a, y_2);
  }
}</code></pre>
    </div>
  </section>

  <section>
    <h3>Вложенные блоки</h3>
    <div style="float: left; width: 35%;">
      <pre><code class="cpp" data-trim data-noescape>void cmp(int a, int b)
{
  if (a > b) {
    foo(1);
  } else {
    if (a == b)
      foo(0);
    else
      foo(-1);
  }
}</code></pre>
    </div>
    <div style="float: right; width: 62%;">
      <pre><code class="cpp" data-trim data-noescape>
void cmp(int a, int b) {
bb_0:
  if (a > b) goto bb_1; else goto bb_2;
bb_1:
  foo(1);
  goto bb_5;
bb_2:
  if (a == b) goto bb_3; else goto bb_4;
bb_3:
  foo(0);
  goto bb_5;
bb_4:
  foo(-1);
bb_5:
  return;
}
      </code></pre>
    </div>
  </section>

  <section>
    <h3>Циклы</h3>
    <div style="float: left; width: 60%;">
      <pre style="margin-bottom: 10px;"><code class="cpp" data-trim data-noescape>
void count(int n) {
  for (int i = 0; i < n; i += 5)
    foo(i);
}
      </code></pre>
      <pre><code class="cpp" data-trim data-noescape>
void count(int n) {
  int i;
bb_0:
  i = 0;
  goto bb_2;
bb_1:
  foo(i);
  i = i + 5;
bb_2:
  if (i < n) goto bb_1; else goto bb_3;
bb_3:
  return;
}
      </code></pre>
    </div>
    <div style="float: right; width: 35%; padding-right:0px;">
      <img class="fragment" src="images/cfg-loop.png" style="height:550px;">
    </div>
    <aside class="notes">
      Базовые блоки, граф потока управления, естественные циклы.
    </aside>
  </section>

  <section>
    <h3>SSA: Static Single Assignment</h3>
    <div style="height: 550px; padding: 0;">
      <pre><code class="cpp" data-trim data-noescape>
int redundant(int x) {
  int y<span class="fragment fade-out" data-fragment-index="1"> = 10</span>;
  <span class="fragment fade-out" data-fragment-index="1">y += x;</span>
  if (x > 0)
    y = 1;
  else
    y = 2;
  return y;
}
      </code></pre>
    </div>
  </section>

  <section>
    <h3>SSA: Static Single Assignment</h3>
    <div style="height: 550px; padding: 0;">
      <div style="float: left; width: 60%; padding-top:50px;">
        <pre><code class="cpp" data-trim data-noescape>
int redundant(int x) {
  int y;
bb_0:
  y = 10;
  y = y + x;
  if (x > 0) goto bb_1; else goto bb_2;
bb_1:
  y = 1;
  goto bb_2;
bb_2:
  y = 2;
bb_3:
  return y;
}
        </code></pre>
      </div>
      <div style="float: right; width: 30%; padding-right:0px;">
        <img src="images/cfg-ssa1.png" style="height:540px;">
      </div>
    </div>
  </section>

  <section>
    <h3>SSA: Static Single Assignment</h3>
    <div style="height: 550px; padding: 0;">
      <div style="float: left; width: 60%; padding-top:50px;">
        <pre><code class="cpp" data-trim data-noescape>
int redundant(int x) {
  int y_0, y_1, y_2, y_3, y_4;
bb_0:
  y_0 = 10;
  y_1 = y_0 + x;
  if (x > 0) goto bb_1; else goto bb_2;
bb_1:
  y_2 = 1;
  goto bb_3;
bb_2:
  y_3 = 2;
bb_3:
  y_4 = <span class="fragment"><span style="font-family: serif; font-size:1.3em;">&phi;</span>(y_2, y_3);</span>
  return y4;
}
        </code></pre>
      </div>
      <div style="float: right; width: 30%; padding-right:0px;">
        <img src="images/cfg-ssa2.png" style="height:540px;">
      </div>
    </div>
  </section>

  <section>
    <h3>Характеристики промежуточного представления</h3>
    <ul>
      <li>Код функции представлен в виде <b>графа потока управления</b></li>
      <li>Вершины графа (<b>базовые блоки</b>) состоят из линейных списков инструкций</li>
      <li>Все вычисления представлены в виде <b>трёхадресного кода</b></li>
      <li>Скалярные переменные переведены в <b>SSA-форму</b></li>
      <li>Типы данных и операции согласуются с наборами инструкций современных процессоров</li>
    </ul>
  </section>

  <section>
    <h3>Вывод промежуточного представления</h3>
    <ul>
      <li>Граф потока управления в формате dot:<br>
        <div class="cmdline"><i class="fa fa-terminal"></i> gcc -c test.c -fdump-tree-cfg-graph</div>
      </li>
      <li>Дамп программы в SSA-форме:<br>
        <div class="cmdline"><i class="fa fa-terminal"></i> gcc -c test.c -fdump-tree-ssa</div>
      </li>
      <li>SSA-форма а виде графа:<br>
        <div class="cmdline"><i class="fa fa-terminal"></i> gcc -c test.c -fdump-tree-ssa-graph</div>
      </li>
    </ul>
  </section>
<!-- #endregion -->

<!-- #region Оптимизации компилятора -->
  <section>
    <h2>Оптимизации компилятора</h2>
  </section>

  <!-- #region Оптимизатор - общая информация -->
  <section>
    <h3>Понятие оптимизации</h3>
    <p>Оптимизация, выполняемая компилятором &mdash; улучшение (в отличие от
      понятия оптимизации в математике).</p>
    Изначальные источники не оптимальности:
    <ul>
      <li>Код, генерируемый макросами или другими программами</li>
      <li>Выбор, сделанный в пользу читаемости, лёгкости поддержки и скорости разработки</li>
      <li>Ограничения языка</li>
    </ul>
  </section>

  <section>
    <h3>Конвейер оптимизатора</h3>
    <img src="images/pipeline.svg" style="width:100%">
    <ul>
      <li>Разные проходы используют (по возможности) общее промежуточное представление</li>
      <li>Конкретный набор проходов зависит от настроек и целевой архитектуры</li>
      <li>Всего проходов около 250</li>
    </ul>
  </section>

  <section>
    <h3>Общие принципы и подходы</h3>
    <ul>
      <li>Поиск инвариантов и упрощение кода на их основе</li>
      <li>Удаление избыточных операций</li>
      <li>Перемещение кода для избегания избыточных вычислений</li>
      <li>Дублирование и специализация кода</li>
      <li>Использование знаний об архитектуре процессора для генерации более оптимального кода</li>
      <li>Эвристики: оптимизация более вероятного случая за счёт пессимизации менее вероятного</li>
    </ul>
  </section>

  <section>
    <h3>Классификация оптимизаций</h3>
    <p>
      По охватываемой области:
      <ul>
        <li>Локальные (базовый блок)</li>
        <li>Глобальные (функция)</li>
        <li>Межпроцедурные (модуль или программа)</li>
      </ul>
    </p>
    <p>
      Отдельно можно выделить машинно-зависимые оптимизации, оптимизации циклов и др.
    </p>
  </section>
  <!-- #endregion -->

  <!-- #region Локальные оптимизации -->
  <section>
    <h3>Примеры локальных оптимизаций</h3>
    <ul>
      <li>Свёртка полностью константных выражений</li>
      <li>Упрощения, основанные на алгебраических тождествах, например:
        <ul>
          <li><tt>x + 0</tt>&emsp;<i class="fa fa-long-arrow-right"></i>&emsp;<tt>x</tt></li>
          <li><tt>1 &amp;&amp; y</tt>&emsp;<i class="fa fa-long-arrow-right"></i>&emsp;<tt>y</tt></li>
          <li><tt>x - x</tt>&emsp;<i class="fa fa-long-arrow-right"></i>&emsp;<tt>0</tt></li>
        </ul>
      </li>
      <li>Оптимизации последовательностей инструкций процессора по шаблону</li>
    </ul>
  </section>

  <section>
    <h3>DSL для описания тождеств</h3>
    Richard Biener <a href="https://www.youtube.com/watch?v=Tlr_mIZ82-U">
      <i class="fa fa-youtube-play"></i>
        Unifying GENERIC and GIMPLE folding with a Pattern Description</a></li>
    <pre style="margin-top:10px;">
/* ~~x -&gt; x */
(simplify
  (bit_not (bit_not @0))
  @0)

/* Simplify sin(x) / tan(x) -&gt; cos(x). */
(simplify
 (rdiv (SIN:s @0) (TAN:s @0))
 (if (! HONOR_NANS (@0)
      &amp;&amp; ! HONOR_INFINITIES (@0))
  (COS @0)))
    </pre>
  </section>
  <!-- #endregion -->

  <!-- #region Глобальные оптимизации -->
  <section>
    <h3>Глобальные оптимизации</h3>
    <p>Затрагивают сразу несколько базовых блоков (вплоть до функции целиком).</p>
    <ul>
      <li>Распространение констант и копий</li>
      <li>Устранение мёртвого кода</li>
      <li>Устранение избыточных вычислений</li>
      <li>Устранение общих подвыражений</li>
      <li>Перемещение кода</li>
    </ul>
  </section>

  <section>
    <h3>Пример: распространение диапазонов значений</h3>
      <div style="height: 550px; padding: 0;">
        <pre><code class="plain-c" data-trim data-noescape>
int encode_image(int coeff, image_data *in, output_stream *out) {
  if (coeff < 0 || coeff > 100)
    return -EINVAL;
  return do_encode(coeff, in, out);
}

int encode_image_simple(quality q, image_data *in, output_stream *out) {
  int coeff;
  switch (q) {
  case Q_LOW:
    coeff = 50; break;
  case Q_MED:
    coeff = 75; break;
  case Q_HIGH:
    coeff = 90; break;
  default:
    return -EINVAL;
  }
  return encode_image(coeff, in, out);
}
    </code></pre>
  </section>

  <section>
    <h3>Пример: распространение диапазонов значений</h3>
    <div style="height: 550px; padding: 0;">
      <div style="height: 550px; float: left; width: 65%;">
        <pre><code class="plain-c" data-trim data-noescape>
int encode_image_simple(quality q,
                        image_data *in,
                        output_stream *out) {
  int coeff;
  switch (q) {
  case Q_LOW:
    coeff = 50; break;
  case Q_MED:
    coeff = 75; break;
  case Q_HIGH:
    coeff = 90; break;
  default:
    return -EINVAL;
  }
  // coeff: [50, 90]
  if (coeff < 0 || coeff > 100)
    return -EINVAL;
  return do_encode(coeff, in, out);
}
        </code></pre>
      </div>
      <div style="height: 550px; float: left; width: 30%;">
        <img src="images/cfg-vrp1.png">
      </div>
    </div>
  </section>

  <section>
    <h3>Пример: распространение диапазонов значений</h3>
    <div style="height: 550px; padding: 0;">
      <div style="height: 550px; float: left; width: 65%;">
        <pre><code class="plain-c" data-trim data-noescape>
int encode_image_simple(quality q,
                        image_data *in,
                        output_stream *out) {
  int coeff;
  switch (q) {
  case Q_LOW:
    coeff = 50; break;
  case Q_MED:
    coeff = 75; break;
  case Q_HIGH:
    coeff = 90; break;
  default:
    return -EINVAL;
  }

  return do_encode(coeff, in, out);
}
        </code></pre>
      </div>
      <div style="height: 550px; float: left; width: 30%;">
        <img src="images/cfg-vrp2.png">
      </div>
    </div>
  </section>

  <section>
    <h3>Оптимизация циклов</h3>
    <p>Состоит из несколько фаз (проходов). Анализ циклов включает в себя:</p>
    <ul>
      <li>Нахождение переменной индукции</li>
      <li>Оценку количества итераций цикла</li>
      <li>Анализ зависимости данных</li>
    </ul>
    <p>Полученные данные позволяют выполнять преобразования циклов, которые:</p>
    <ul>
      <li>Устраняют избыточные вычисления</li>
      <li>Увеличивают эффективность использования кэша</li>
      <li>Делают возможной векторизацию кода</li>
    </ul>
    <aside class="notes">
      Устраняют избыточные вычисления - LIM и PCOM<br>
      Увеличивают эффективность использования кэша - ldist
    </aside>
  </section>

  <section>
    <h3>Пример: размыкание цикла</h3>
    <div style="height: 550px; padding: 0;">
      <pre><code class="cpp" data-trim data-noescape>
void unswitch(char *x, int n, bool flag)
{
<span class="fragment" data-fragment-index="1">  if (flag) {</span>
    for (int i = 0; i < n; i++)
      if (flag)
        foo(x[i]);
      else
        bar(x[i]);
<span class="fragment" data-fragment-index="1">  } else {
    for (int i = 0; i < n; i++)
      if (flag)
        foo(x[i]);
      else
        bar(x[i]);
  }</span>
}
      </code></pre>
    </div>
  </section>

  <section>
    <h3>Пример: размыкание цикла</h3>
      <div style="height: 550px; padding: 0;">
        <pre><code class="cpp" data-trim data-noescape>
void unswitch(char *x, int n, bool flag)
{
  if (flag) {
    for (int i = 0; i < n; i++)
      <span class="fragment fade-out" data-fragment-index="1">if (true)</span>
        foo(x[i]);
<span class="fragment fade-out" data-fragment-index="1">      else
        bar(x[i]);</span>
  } else {
    for (int i = 0; i < n; i++)
      <span class="fragment fade-out" data-fragment-index="1">if (false)
        foo(x[i]);
      else</span>
        bar(x[i]);
  }</span>
}
      </code></pre>
    </div>
  </section>

  <section>
    <h3>Пример: размыкание цикла</h3>
      <div style="height: 550px; padding: 0;">
        <div class="half">
          <pre><code class="cpp" data-trim data-noescape>
void unswitch(char *x, int n,
              bool flag)
{
  for (int i = 0; i < n; i++)
    if (flag)
      foo(x[i]);
    else
      bar(x[i]);
}
          </code></pre>
        </div>
        <div class="half">
          <pre><code class="cpp" data-trim data-noescape>
void unswitch(char *x, int n,
              bool flag)
{
  if (flag) {
    for (int i = 0; i < n; i++)
      foo(x[i]);
  } else {
    for (int i = 0; i < n; i++)
      bar(x[i]);
  }
}
        </code></pre>
      </div>
    </div>
  </section>
  <!-- #endregion -->

  <!-- #region Межпроцедурные оптимизации -->
  <section>
    <h3>Межпроцедурные оптимизации</h3>
    <p>Распространяют по графу вызовов информацию:</p>
    <ul>
      <li>Константность и диапазоны значений параметров</li>
      <li>(не)использование параметров в функции</li>
      <li>Выравнивание указателей</li>
      <li>Динамические типы объектов</li>
    </ul>
    <p>Собранная информация позволяет оптимизировать функцию либо создать
      несколько версий одной функции, которые лучше поддаются оптимизации.</p>
  </section>

  <section>
    <div style="margin-bottom:10px;">
      <span class="cmdline"><i class="fa fa-terminal"></i>
        gcc -O2 -fno-inline -S test.c</span>
    </div>
    <div class="half">
      <pre><code class="cpp" data-trim data-noescape>
// test.c

struct point {
  int x, y, z;
};

static int
foo(const struct point *p) {
  return p->x + p->y;
}

int
bar(int x, int y) {
  struct point p = {x, y, 0};
  return foo(&p);
}
      </code></pre>
    </div>
    <div class="half">
      <pre><code class="cpp" data-trim data-noescape>
// После применения оптимизации
// "межпроцедурная скалярная
// замена агрегатов"



static int
foo_isra_0(int p0, int p1) {
  return p0 + p1;
}

int
bar(int x, int y) {
  return foo_isra_0(x, y);
}
      </code></pre>
    </div>
  </section>

  <section>
    <h3>Встраивание</h3>
    Встраивание (inlining) &mdash; замена операции вызова функции телом вызываемой функции.
    <ul>
      <li>Основная польза &mdash; открывает возможности для других оптимизаций</li>
      <li>Нетривиально влияет на размер программы и работу кэша инструкций</li>
      <li>В языках C и C++ даже есть ключевое слово <tt>inline</tt>, имеющее косвенное отношение к
        встраиванию</li>
    </ul>
    <aside class="notes">
      Компилятор может использовать информацию о контексте для оптимизации тела встроенной функции,
      и наоборот "видя" тело функции принимать правильные решения в точке вызова.<br>
      С одной стороны, переходы - это плохо (подгружаем лишние данные в кэш), с другой стороны
      рост размера функции ведёт к той же проблеме.<br>
      <tt>inline</tt> влияет на эвристики, воспринимается как рекомендация<br>
    </aside>
  </section>

  <section>
    <h3>Встраивание: польза в простейшем случае</h3>
    <pre><code class="cpp" data-trim data-noescape style="margin-bottom:10px;">
static long add2(long *a, long *b) {
  return *a + *b;
}

long add3(long *a, long *b, long *c) {
  return add2(a, b) + *c;
}
    </code></pre>
    <div class="half">
      <pre><code class="asm" data-trim data-noescape>
; gcc -c test.c -O -fno-inline

add2: ; rsi = a, rdi = b
  mov     rax, QWORD PTR [rsi]
  add     rax, QWORD PTR [rdi]
  <span class="fragment strike" data-fragment-index="1">ret</span>

add3: ; rsi=a, rdi=b, rdx=c
  <span class="fragment strike" data-fragment-index="2">push    rbx</span>
  <span class="fragment strike" data-fragment-index="2">mov     rbx, rdx</span>
  <span class="fragment strike" data-fragment-index="1">call    add2</span>
  add     rax, QWORD PTR [rbx]
  <span class="fragment strike" data-fragment-index="2">pop     rbx</span>
  ret
      </code></pre>
    </div>
    <div class="half">
      <pre><code class="asm" data-trim data-noescape>
; gcc -c test.c -O






add3: ; rsi=a, rdi=b, rdx=c
  mov     rax, QWORD PTR [rsi]
  add     rax, QWORD PTR [rdi]
  add     rax, QWORD PTR [rdx]
  ret
      </code></pre>
    </div>
    <aside class="notes">
      Многие считают, что вызов и возврат из функции - быстрые операции (так и есть).<br>
      Но вызов включает в себя сохранение регистров, подготовку передаваемых аргументов и
      восстановление значений регистров<br>
      У встраиваемой функции может быть пролог и эпилог, от которых мы также избавимся
    </aside>
  </section>

  <section>
    <h3>Встраивание и C++</h3>
    <pre><code class="cpp" data-trim>
#include &lt;vector&gt;
#include &lt;numeric&gt;

long sum(const std::vector&lt;long&gt;&amp; vec) {
  return std::accumulate(vec.begin(), vec.end(), 0L);
}
    </code></pre>
    <div class="center-wrapper" style="padding-top:10px;">
      <img src="images/no-inline.svg" style="height:300px;">
    </div>
  </section>

  <section>
    <h3>Эвристики встраивания</h3>
    <p>
      Встраивание производится двумя проходами оптимизатора, которые
      используют разные алгоритмы.
    </p>
    <ol>
      <li>Ранний этап: граф вызовов обходится в топологическом порядке, основной критерий &mdash;
        размер вызываемой функции.</li>
      <li>Поздний этап: для каждого вызова (ребра в графе) рассчитывается сложная
        метрика, которая моделирует пользу от встраивания вызова.
        Используется очередь с приоритетами.</li>
    </ol>
    <p>
      <a href="https://lkml.org/lkml/2009/1/9/290"><i class="fa fa-external-link"></i> Жаркая дискуссия Линуса Торвальдса
        и мэйнтейнера GCC на тему эвристик</a> <i class="fa fa-fire" style="color:#f47442"></i>
    </p>
    <aside class="notes">
      На раннем этапе компилятор пытается уменьшить объём работы для "тяжелой артиллерии" и
      встроить многочисленные begin, end, size и т.п. Вызываемые функции всегда обрабатываются
      перед вызывающими, каждая функция посещается 1 раз<br>
      На позднем этапе возможно рекурсивное встраивание, т.к. порядок обхода произвольный. GCC
      пытается оценить, насколько изменится размер функции, если её параметр станет после встраивания
      константой и учитывает это в метрике.<br>
      Есть куча настроек и атрибутов, позволяющих контролировать процесс вручную (типа flatten)
    </aside>
  </section>
  <!-- #endregion -->

  <!-- #region Back end и машинно-зависимые оптимизации -->
  <section>
    <h3>Back end и машинно-зависимые оптимизации</h3>
    Каждый back end в GCC включает в себя:
    <ul>
      <li>Код (на языке C++), специфичный для компиляции под конкретную архитектуру</li>
      <li>Описание архитектуры (инструкций, регистров и т.д.) на особом DSL</li>
    </ul>
    Проход оптимизатора <b>expand</b> преобразует код <b>GIMPLE</b> в машинно-зависимое представление
    <b>RTL</b>.
  </section>

  <section>
    <h3>Пример: выбор инструкции для 8-битного деления</h3>
    <p>Попробуем скомпилировать программу:</p>
    <pre><code class="cpp" data-trim data-noescape>
uint8_t mod(uint8_t a, uint8_t b) {
    return a % b;
}
    </code></pre>
    <p>Описание архитектуры процессора содержит таблицы поддерживаемых стандартных операций.
    Компилятор попытается найти в них что-нибудь подходящее, например:
    <ul>
      <li><tt>umod</tt></li>
      <li><tt>udivmod</tt></li>
      <li><tt>udiv</tt> и вычислить по формуле <tt>a - (a/b)</tt></li>
      <li>то же самое, но для типов большей разрядности</li>

    </ul></p>
    <p>В итоге (на x86) удастся найти шаблон <tt>udivmod</tt> для <tt>uint8_t</tt></p>
  </section>

  <section>
    <h3>Выбранный шаблон и реальная инструкция</h3>
    <pre><code class="cpp" data-trim data-noescape>
// Псевдокод шаблона udivmod
void udivmodqi4(uint8_t dividend, uint8_t divisor,
                uint8_t *remainder, uint8_t* quotient)
{
  *quotient = dividend / divisor;
  *remainder = dividend % divisor;
}

// Но в x86 инструкция деления работает несколько иначе.
// Псевдокод шаблона инструкции div для 8-битного делителя
// (с некоторыми допущениями):
void udivmodhiqi3(uint16_t dividend, uint8_t divisor, uint16_t *result)
{
  uint16_t quotient = (uint8_t)(dividend / (uint16_t)divisor);
  uint16_t remainder = (uint8_t)(dividend % (uint16_t)divisor);
  *result = (remainder << 8) | quotient;
}
    </code></pre>
  </section>

  <section>
    <h3></h3>
    <pre><code class="cpp" data-trim data-noescape>
// Реальная инструкция процессора делает не совсем то, что нам нужно
void udivmodhiqi3(uint16_t dividend, uint8_t divisor, uint16_t *result)
{
  uint16_t quotient = (uint8_t)(dividend / (uint16_t)divisor);
  uint16_t remainder = (uint8_t)(dividend % (uint16_t)divisor);
  *result = (remainder << 8) | quotient;
}

// Напишем адаптер
void udivmodqi4(uint8_t dividend, uint8_t divisor,
                uint8_t *remainder, uint8_t* quotient)
{
  union {
    uint16_t u16;
    struct { uint8_t low; uint8_t high; };
  } result;

  udivmodhiqi3((uint16_t)dividend, divisor, &result.u16);
  *remainder = result.high;
  *quotient = result.low;
}
    </code></pre>
  </section>

  <section>
    <h3>Описание инструкции деления в компиляторе</h3>
    <pre style="font-size:20px;">
;; Операнд 0 - результат <span class="fragment highlight-current-red" data-fragment-index="3">((remainder << 8) | quotient)</span>
;; Операнд 1 - делимое
;; Операнд 2 - делитель

(define_insn "udivmodhiqi3"
  [(set <span class="fragment highlight-current-red" data-fragment-index="1">(match_operand:HI 0 "register_operand" "=a")</span>
        <span class="fragment highlight-current-red" data-fragment-index="3">(ior:HI
          (ashift:HI
            (zero_extend:HI
              (truncate:QI
                <span class="fragment highlight-current-red" data-fragment-index="2">(mod:HI <span class="fragment highlight-current-red" data-fragment-index="1">(match_operand:HI 1 "register_operand" "0")</span>
                        (zero_extend:HI
                          <span class="fragment highlight-current-red" data-fragment-index="1">(match_operand:QI 2 "nonimmediate_operand" "qm")</span>))</span>))
            (const_int 8))
          (zero_extend:HI
            (truncate:QI
              <span class="fragment highlight-current-red" data-fragment-index="2">(div:HI <span class="fragment highlight-current-red" data-fragment-index="1">(match_dup 1)</span> (zero_extend:HI <span class="fragment highlight-current-red" data-fragment-index="1">(match_dup 2)</span>))</span>)))</span>)
   (clobber (reg:CC FLAGS_REG))]
  "TARGET_QIMODE_MATH"
  "div{b}\t%2"
  [(set_attr "type" "idiv")
   (set_attr "mode" "QI")])</pre>
</section>

  <section>
    <div class="center-wrapper" style="height:500px;">
      <h3>И так для каждой инструкции...</h3>
      <img src="images/horror.jpg">
    </div>
  </section>

  <section>
    <h3>Примеры машинно-зависимых оптимизаций</h3>
    <ul>
      <li>Переупорядочение базовых блоков</li>
      <li>Выделение регистров</li>
      <li>Планирование инструкций</li>
    </ul>
  </section>

  <section>
    <h3>Переупорядочение базовых блоков</h3>
      <div style="float: left; width: 70%;">
        <pre><code class="cpp" data-trim data-noescape>
#define likely(x)    __builtin_expect((x),1)

int foo(int x) {
  if (likely(x < 0))
    <span class="fragment semi-fade-out-current" data-fragment-index="2">x = bar(x);</span>
  <span class="fragment semi-fade-out-current" data-fragment-index="1">else
    x = baz(x);</span>
  return x + 5;
}
      </code></pre>
      <pre style="margin-top:10px;"><code class="asm" data-trim data-noescape>
foo: ; edi = x
    sub     rsp, 8
    test    edi, edi
    <span class="fragment mark-current" data-fragment-index="2">jns     .L2</span>
    <span class="fragment semi-fade-out-current" data-fragment-index="2">call    bar</span>
.L3:
    add     eax, 5
    add     rsp, 8
    ret
<span class="fragment semi-fade-out-current" data-fragment-index="1">.L2:
    call    baz
    <span class="fragment mark-current" data-fragment-index="2">jmp     .L3</span></span>
      </code></pre>
    </div>
    <img src="images/cfg-bbro1.svg" style="height:550px;">
  </section>
  <!-- #endregion -->

  <section>
    <h3>Полезные команды для изучения компилятора</h3>
    <ul>
      <li>показать ключи, отвечающие за оптимизацию и их состояния:<br>
        <span class="cmdline"><i class="fa fa-terminal"></i>
          gcc -O3 -Q --help=optimizers test.c</span></li>
      <li>показать список активных проходов с оптимизацией <tt>-O2</tt>:<br>
        <span class="cmdline"><i class="fa fa-terminal"></i>
          gcc -fdump-passes -O2 file.c</span></li>
      <li>вывести промежуточное представление после каждого прохода в отдельный файл файл:<br>
        <span class="cmdline"><i class="fa fa-terminal"></i> gcc &#8209;fdump&#8209;tree&#8209;all
          &#8209;fdump&#8209;ipa&#8209;all &#8209;fdump&#8209;rtl&#8209;all -O2 file.c</span></li>
    </ul>
  </section>
<!-- #endregion -->

<!-- #region Практическая применимость -->
  <section>
    <h2>Практическая применимость</h2>
    <blockquote>
      The real problem is that programmers have spent far too much time worrying about efficiency
      in the wrong place and at the wrong times; premature optimization is the root of all evil
      (or at least most of it) in programming.
      <div style="text-align: right;">Donald Ervin Knuth</div>
    </blockquote>
  </section>

  <section>
    <h3>Влияние оптимизаций компилятора на производительность</h3>
    <div class="half">
      <img src="images/bench-bubble.svg" height="width=100%">
    </div>
    <div class="half">
      <img src="images/bench-quick.svg" height="width=100%">
    </div>
  </section>

  <section>
    <h3>Чем может помочь программисту знание устройства компилятора</h3>
    <ul>
      <li>Не усложнять код ручной оптимизацией без необходимости</li>
      <li>Уметь оптимизировать критичные участки кода (в том числе, используя
          возможности компилятора)<br>
      </li>
    </ul>
    <p>
      <i class="fa fa-file-text-o"></i> Agner Fog
      <a href="http://www.agner.org/optimize/optimizing_cpp.pdf"><i class="fa fa-external-link"></i>
        Optimizing software in C++</a>
    </p>
  </section>
<!-- #endregion -->

<!-- #region Разработчики GCC и пользователи -->
  <section>
    <h2>Разработчики GCC и пользователи</h2>
  </section>

  <section>
    <h3>Корпоративные разработчики GCC</h3>
    <div style="float:left; width:70%">
      Компании Red Hat и SUSE активно работают над ключевыми компонентами GCC:
      <ul>
        <li>Front end языка C++ и его стандартная библиотека</li>
        <li>Предупреждения компилятора (C, C++)</li>
        <li>Генерация отладочной информации</li>
        <li>Оптимизации</li>
      </ul>
    </div>
    <div style="float:left; width:30%;">
      <img src="images/logo-redhat.png">
      <img src="images/logo-suse.png" style="width:200px;">
    </div>
  </section>

  <section>
    <h3>Корпоративные разработчики GCC</h3>
    <p>Поддержкой back-end компонентов обычно занимаются разработчики железа:<p>
    <div class="center-wrapper" style="height:200px;">
      <img src="images/logos-hardware.png">
    </div>
    <p>Языки Go и Ada также поддерживаются крупными компаниями:</p>
    <div class="center-wrapper" style="height:100px;">
      <img src="images/logos-langs.png">
    </div>
  </section>

  <section>
    <h3>Сообщество разработчиков GCC</h3>
    <ul>
      <li><a href="https://gcc.gnu.org/lists.html">
        <i class="fa fa-external-link"></i> Списки рассылки</a> (gcc-help)</li>
      <li><a href="https://gcc.gnu.org/bugzilla">
        <i class="fa fa-external-link"></i> Баг-трекер</a></li>
      <li><a href="https://gcc.gnu.org/wiki">
        <i class="fa fa-external-link"></i> GCC Wiki</a></li>
      <li><a href="https://stackoverflow.com/questions/tagged/gcc">
        <i class="fa fa-stack-overflow"></i> Тэг на Stack Overflow</a></li>
    </ul>
  </section>

  <section>
    <h3>Тестирование GCC &mdash; взаимовыгодное сотрудничество</h3>
    <a href="https://gcc.gnu.org/testing/"><i class="fa fa-external-link"></i> GCC Testing Efforts</a>
    <p>Попробуйте использовать для сборки вашего кода еженедельные снэпшоты GCC (и прогонять
      unit-тесты).</p>
    Взамен за потраченные усилия вы:
    <ul>
      <li>раньше получите доступ к новым предупреждениям компилятора</li>
      <li>сможете указать на ошибку, которая проявляется именно на вашем коде (и рассчитывать на
        её исправление до релиза)</li>
      <li>отслеживать регрессии в производительности генерируемого кода</li>
    </ul>
  </section>

  <section>
    <h3>Примеры из нашей работы</h3>
    <ul class="fa-ul">
      <li><i class="fa-li fa fa-check-square"></i>
        <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65071">PR 65071</a>
        <!--ICE on valid, sizeof...() of template template parameter pack in return type-->
        Использование <tt>sizeof...</tt> в типе возвращаемого значения в некоторых
        случаях приводит к внутренней ошибке компилятора</li>
      <li><i class="fa-li fa fa-check-square"></i>
        <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66572">PR 66572</a>
        <!-- Bogus Wlogical-op warning for operands coming from template instantiations -->
        <tt>Wlogical-op</tt> даёт ложноположительные срабатывания из-за шаблонов</li>
      <li><i class="fa-li fa fa-check-square"></i>
        <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65876">PR 65876</a>
        <!-- ICE in cxx_eval_call_expression, at cp/constexpr.c:1358 -->
        Внутренняя ошибка компилятора связанная с <tt>constexpr</tt>-инициализацией</li>
      <li><i class="fa-li fa fa-bug"></i>
        <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67694">PR 67694</a>
        <!-- ICE on returning undefined enum in must_pass_in_stack_var_size_or_pad -->
        Внутренняя ошибка компилятора при возврате объявленного, но не определённого <tt>enum</tt>-а
        (Objective C)</li>
      <li><i class="fa-li fa fa-check-square"></i>
        <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67854">PR 67854</a>
        <!-- Missing diagnostic for passing bool to va_arg -->
        Отсутствует предупреждение при передаче <tt>bool</tt> в качестве <tt>va_arg</tt></li>
    </ul>
  </section>
<!-- #endregion -->

<!-- #region Дополнительные источники, Бонус и завершение -->
  <section>
    <h2>Дополнительные источники информации</h2>
  </section>

  <section>
    <h3>Темы, которые пришлось обойти стороной</h3>
    <ul>
      <li>Реализация ABI, исключения C++</li>
      <li>Как SSA уживается с указателями (анализ псевдонимов)</li>
      <li>Роль неопределённого поведения в оптимизации</li>
      <li>Математические основы: доминаторы в графах, решётки сбора</li>
      <li>Машинно-зависимые оптимизации: распределение регистров, планирование инструкций</li>
      <li>Модель памяти, атомарные операции, многопоточность</li>
      <li>Оптимизация времени компоновки (LTO)</li>
      <li>Работа sanitizer-ов и анализа покрытия</li>
    </ul>
  </section>

  <section>
    <h3>Литература и доклады о компиляторах</h3>
    <div style="float:left; width:70%;">
      <ul>
        <li><a href="https://gcc.gnu.org/wiki/ListOfCompilerBooks">
          <i class="fa fa-external-link"></i> Рецензии на книги</a>
          составленные разработчиками GCC</li>
        <li>Robert Morgan. <a href="http://www.amazon.com/Building-Optimizing-Compiler-Bob-Morgan/dp/155558179X">
          <i class="fa fa-book"></i> Building an Optimizing compiler</a> (1998)</li>
        <li>Chandler Carruth. <a href="https://www.youtube.com/watch?v=FnGCDLhaxKU">
          <i class="fa fa-youtube-play"></i> Understanding Compiler Optimization</a>
        </li>
        <li>Chandler Carruth.
          <a href="https://www.youtube.com/watch?v=nXaxk27zwlk">
            <i class="fa fa-youtube-play"></i> Tuning C++: Benchmarks, and CPUs, and Compilers! Oh My!</a>
        </li>
      </ul>
    </div>
    <img src="images/rob_morgan_book.jpg" style="float:right; width:25%">
  </section>

  <section>
    <h3>Подробнее об устройстве GCC</h3>
    <ul>
      <li><a ref="https://gcc.gnu.org/onlinedocs/gccint/">
        <i class="fa fa-external-link"></i> GNU Compiler Collection (GCC) Internals</a></li>
      <li>IIT Bombay. <a href="http://www.cse.iitb.ac.in/grc/index.php?page=videos">
        <i class="fa fa-external-link"></i>
        Essential Abstractions in GCC</a> (2012) &mdash; курс из 12 видео лекций</li>
      <li>David Malcolm. <a href="https://dmalcolm.fedorapeople.org/gcc/newbies-guide/index.html">
        <i class="fa fa-external-link"></i>
        GCC for New Contributors</a></li>
    </ul>
  </section>

  <section>
    <h2>Бонус</h2>
  </section>

  <section>
    <h3>Новые фичи GCC, над которыми ведётся работа</h3>
    <ul>
      <li><a href="https://gcc.gnu.org/wiki/cxx-modules"><i class="fa fa-external-link"></i> Модули C++</a></li>
      <li><a href="https://gcc.gnu.org/ml/gcc-patches/2017-05/msg02108.html"><i class="fa fa-external-link"></i> Поддержка языка D</a></li>
      <li><a href="https://developers.redhat.com/blog/2017/07/11/statement-frontier-notes-and-location-views/#more-437095">
        <i class="fa fa-external-link"></i> Больше отладочной информации</a> для оптимизированных программ</li>
      <li><a href="https://gcc.gnu.org/ml/gcc-patches/2017-07/msg00556.html"><i class="fa fa-external-link"></i> Противодействие</a> атакам
        <a href="https://access.redhat.com/security/vulnerabilities/stackguard"><i class="fa fa-external-link"></i> Stack Clash</a></li>
      <li>Более понятные сообщения об ошибках и больше fix-it подсказок
        <ul>
          <li><a href="https://gcc.gnu.org/ml/gcc-patches/2017-05/msg00353.html">
            <i class="fa fa-external-link"></i> &laquo;diff&raquo; для не совпадающих шаблонных типов
          </a></li>
        </ul>
      </li>
      <li>Более качественная оптимизация конструкции switch</li>
      <li>Улучшения оптимизаций циклов и векторизации</li>
      </li>
      <li><a href="https://gcc.gnu.org/ml/gcc-patches/2017-07/msg01448.html"><i class="fa fa-external-link"></i> Language Server</a>
        (возможно когда-нибудь)</li>
      <li>Поддержка новых возможностей процессоров Intel (CET) и ARM (SVE)</li>
    </ul>
  </section>

  <!-- Спасибо за внимание! -->
  <section>
    <h1>Спасибо за внимание!</h1>
    <div class="link-bitly"><a href="https://bit.ly/gcc_">
      <i class="fa fa-external-link"></i> bit.ly/gcc_</a>
    </div>
  </section>
<!-- #endregion -->

<!-- #region HTML footer -->
</div></div>
  <script src="lib/js/head.min.js"></script>
  <script src="js/reveal.js"></script>
  <script src="js/pure-c.js"></script>
  <script src="plugin/highlight/cpp.js"></script>
  <script src="plugin/highlight/asm.js"></script>
  <script>
    Reveal.initialize({
      history: true,
      //embedded: true,
      //showNotes: true,
      slideNumber: true,
      touch: false,
      transition: 'fade',
      transitionSpeed: 'fast',
      dependencies: [
        { src: 'plugin/notes/notes.js', async: true },
        { src: 'plugin/highlight/highlight.js', async: true,
          callback: function() { hljs.registerLanguage("pure-c", pureCHighlight);
                                 hljs.registerLanguage("cpp", CPPHightlight);
                                 hljs.registerLanguage("asm", asmHighlight);
                                 hljs.initHighlightingOnLoad(); }
        }
      ]
    });
  </script>
</body>
</html>
<!-- #endregion -->
